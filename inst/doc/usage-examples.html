<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Usage examples</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Usage examples</h1>



<div id="minimal-example" class="section level2">
<h2>Minimal example</h2>
<p>The main function is <code>fit_cumhist()</code> that takes a data
frame with time-series as a first argument. In addition, you need to
specify the name of the column that codes the perceptual state
(<code>state</code> argument) and a column that holds either dominance
phase duration (<code>duration</code>) or its onset
(<code>onset</code>). The code below fits data using Gamma distribution
(default family) for a single run of a single participant. By default,
the function fits cumulative history time constant but uses default
fixed mixed state value (<code>mixed_state = 0.5</code>) and initial
history values (<code>history_init = 0</code>).</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(bistablehistory)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(br_singleblock)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>gamma_fit <span class="ot">&lt;-</span> <span class="fu">fit_cumhist</span>(br_singleblock,</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                         <span class="at">state=</span><span class="st">&quot;State&quot;</span>,</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                         <span class="at">duration=</span><span class="st">&quot;Duration&quot;</span>,</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                         <span class="at">refresh=</span><span class="dv">0</span>)</span></code></pre></div>
<p>Alternatively, you specify <em>onset</em> of individual dominance
phases that will be used to compute their duration.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>gamma_fit <span class="ot">&lt;-</span> <span class="fu">fit_cumhist</span>(br_singleblock,</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>                        <span class="at">state=</span><span class="st">&quot;State&quot;</span>,</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>                        <span class="at">onset=</span><span class="st">&quot;Time&quot;</span>)</span></code></pre></div>
<p>You can look at the fitted value for history time constant using
<code>history_tau()</code></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">history_tau</span>(gamma_fit)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; # A tibble: 1 x 3</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Estimate `5.5%` `94.5%`</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1    0.981  0.764    1.21</span></span></code></pre></div>
<p>and main effect of history for both parameters of gamma
distribution</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">historyef</span>(gamma_fit)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; # A tibble: 2 x 4</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   DistributionParameter Estimate `5.5%` `94.5%`</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   &lt;fct&gt;                    &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1 shape                    1.09   0.214    2.03</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2 scale                    0.236 -0.826    1.31</span></span></code></pre></div>
<p>The following model is fitted for the example above, see also <a href="cumulative-history.html">companion vignette</a> for details on
cumulative history computation. <span class="math display">\[Duration[i]
\sim  Gamma(shape[i], rate[i]) \\
log(shape[i]) = \alpha^{shape} + \beta^{shape}_H \cdot \Delta h[i] \\
log(rate[i]) = \alpha^{rate} + \beta^{rate}_H \cdot \Delta h[i] \\
\Delta h[i] = \text{cumulative_history}(\tau, \text{history_init})\\
\alpha^{shape}, \alpha^{rate} \sim Normal(log(3), 5) \\
\beta^{shape}_H, \beta^{rate}_H \sim Normal(0, 1) \\
\tau \sim Normal(log(1), 0.15)\]</span></p>
</div>
<div id="passing-stan-control-parameters" class="section level2">
<h2>Passing Stan control parameters</h2>
<p>You can pass Stan control parameters via <code>control</code>
argument, e.g.,</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>gamma_fit <span class="ot">&lt;-</span> <span class="fu">fit_cumhist</span>(br_singleblock,</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                        <span class="at">state=</span><span class="st">&quot;State&quot;</span>,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                        <span class="at">duration=</span><span class="st">&quot;Duration&quot;</span>,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>                        <span class="at">control=</span><span class="fu">list</span>(<span class="at">max_treedepth =</span> <span class="dv">15</span>,</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">adapt_delta =</span> <span class="fl">0.99</span>))</span></code></pre></div>
<p>See Stan documentation for details <span class="citation">(Carpenter
et al. 2017)</span>.</p>
</div>
<div id="run" class="section level2">
<h2>Run</h2>
<p>By default, <code>fit_cumhist()</code> function assumes that the
time-series represent a single run, so that history states are
initialized only once at the very beginning. You can use
<code>run</code> argument to pass the name of a column that specifies
individual runs. In this case, history is initialized at the beginning
of every run to avoid spill-over effects.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>gamma_fit <span class="ot">&lt;-</span> <span class="fu">fit_cumhist</span>(br_single_subject,</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>                        <span class="at">state=</span><span class="st">&quot;State&quot;</span>,</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>                        <span class="at">onset=</span><span class="st">&quot;Time&quot;</span>,</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>                        <span class="at">run=</span><span class="st">&quot;Block&quot;</span>)</span></code></pre></div>
</div>
<div id="experimental-session" class="section level2">
<h2>Experimental session</h2>
<p>Experimental session specifies which time-series were measured
together and is used to compute an average dominance phase duration
that, in turn, is used when computing cumulative history: <span class="math inline">\(\tau_H = \tau \cdot &lt;D&gt;\)</span>, where
<span class="math inline">\(\tau\)</span> is normalized time constant
and <span class="math inline">\(&lt;D&gt;\)</span> is the mean dominance
phase duration. This can be used to account for changes in overall
alternation rate between different sessions (days), as, for example,
participants new to the stimuli tend to “speed up” over the course of
days <span class="citation">(Suzuki and Grabowecky 2007)</span>. If you
<em>do not</em> specify <code>session</code> parameter then a single
mean dominance phase duration is computed for all runs of a single
subject.</p>
</div>
<div id="random-effect" class="section level2">
<h2>Random effect</h2>
<p>The <code>random_effect</code> argument allows you to specify a name
of the column that codes for a random effect, e.g., participant
identity, bistable display (if different displays were used for a single
participant), etc. If specified, it is used to fit a hierarchical model
with random slopes for the <em>history effect</em> (<span class="math inline">\(\beta_H\)</span>). Note that we if random
<em>independent</em> intercepts are used as prior research suggest large
differences in overall alternation rate between participants <span class="citation">(Brascamp et al. 2019)</span>.</p>
<p>Here, is the R code that specifies participants as random effect</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>gamma_fit <span class="ot">&lt;-</span>  <span class="fu">fit_cumhist</span>(kde_two_observers,</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>                          <span class="at">state=</span><span class="st">&quot;State&quot;</span>,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                          <span class="at">duration=</span><span class="st">&quot;Duration&quot;</span>,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                          <span class="at">random_effect=</span><span class="st">&quot;Observer&quot;</span>,</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>                          <span class="at">run=</span><span class="st">&quot;Block&quot;</span>)</span></code></pre></div>
<p>And here is the corresponding model, specified for the shape
parameter only as identical formulas are used for the rate parameter as
well. Here, <span class="math inline">\(R_i\)</span> codes for a random
effect level (participant identity) and a non-centered parametrization
is used for the pooled random slopes.</p>
<p><span class="math display">\[Duration[i] \sim  Gamma(shape[i],
rate[i]) \\
log(shape[i]) = \alpha[R_i] + \beta_H[R_i] \cdot \Delta h[i] \\
\Delta H[i] = \text{cumulative_history}(\tau, \text{history_init})\\
\alpha[R_i] \sim Normal(log(3), 5) \\
\beta_H[R_i] = \beta^{pop}_H + \beta^{z}_H[R_i] \cdot \sigma^{pop}_H\\
\beta^{pop}_H \sim Normal(0, 1) \\
\beta^{z}_H[R_i] \sim Normal(0, 1) \\
\sigma^{pop}_H \sim Exponential(1) \\
\tau \sim Normal(log(1), 0.15)\]</span></p>
<p>Identical approach is take for <span class="math inline">\(\tau\)</span>, if <code>tau=&#39; &quot;1|random&quot;&#39;</code>
was specified and same holds for <code>mixed_state=&#39; &quot;1|random&quot;&#39;</code>
argument, see below.</p>
</div>
<div id="fixed-effects" class="section level2">
<h2>Fixed effects</h2>
<p><code>fit_cumhist()</code> functions allows you to specify multiple
fixed effect terms as a vector of strings. The implementation is
restricted to:</p>
<ul>
<li>Only continuous (metric) independent variables should be used.</li>
<li>A single value is fitted for each main effect, irrespective of
whether a random effect was specified.</li>
<li>You cannot specify an interaction either between fixed effects or
between a fixed effect and cumulative history variable.</li>
</ul>
<p>Although this limits usability of the fixed effects, these
restrictions allowed for both a simpler model specification and a
simpler underlying code. If you do require more complex models, please
refer to <a href="writing-stan-code.html">companion vignette</a> that
provides an example on writing model using Stan directly.</p>
<p>You can specify custom priors (a mean and a standard deviation of a
prior normal distribution) via <code>history_effect_prior</code> and
<code>fixed_effects_priors</code> arguments. The former accepts a vector
with mean and standard deviation, whereas the latter takes a named list
in format .</p>
<p>Once fitted, you can use <code>fixef()</code> function to extract a
posterior distribution or its summary for each effect.</p>
</div>
<div id="cumulative-history-parameters" class="section level2">
<h2>Cumulative history parameters</h2>
<p><code>fit_cumhist()</code> function takes three parameters for
cumulative history computation (see also <a href="cumulative-history.html">companion vignette</a>):</p>
<ul>
<li><code>tau</code> : a <em>normalized</em> time constant in units of
mean dominance phase duration.</li>
<li><code>mixed_state</code> : value used for mixed/transition state
phases, defaults to <code>0.5</code>.</li>
<li><code>history_init</code> : an initial value for cumulative history
at the onset of each run. Defaults to <code>0</code>.</li>
</ul>
<p>Note that although <code>history_init</code> accepts only fixed
values either a single value used for both states or a vector of two. In
contrast, both fixed and fitted values can be used for the other three
parameters. Here are possible function argument values</p>
<ul>
<li>a single positive number for <code>tau</code> or single number
within [0, 1] range for <code>mixed_state</code>. In this case, the
value is used directly for the cumulative history computation, which is
default option for <code>mixed_state</code>.</li>
<li><code>NULL</code> : a single value is fitted and used for all
participants and runs. This is a default for <code>tau</code>.</li>
<li><code>&#39;random&#39;</code> : an <em>independent</em> tau is fitted for
each random cluster (participant, displays, etc.).
<code>random_effect</code> argument must be specified.</li>
<li><code>&#39;1|random&#39;</code> : values for individual random cluster are
sampled from a fitted population distribution (<em>pooled</em> values).
<code>random_effect</code> argument must be specified.</li>
</ul>
<p>You can specify custom priors for each cumulative history parameter
via <code>history_priors</code> argument by specifying mean and standard
deviation of a prior normal distribution. The
<code>history_priors</code> argument must be a named list, , e.g.,
<code>history_priors = list(&quot;tau&quot;=c(1, 0.15))</code>.</p>
<p>Once fitted, you can use <code>history_tau()</code> and
<code>history_mixed_state()</code>functions to obtain a posterior
distribution or its summary for each parameter.</p>
</div>
<div id="distribution-family" class="section level2">
<h2>Distribution family</h2>
<p><code>fit_cumhist</code> currently supports three distributions:
<code>&#39;gamma&#39;</code>, <code>&#39;lognormal&#39;</code>, and
<code>&#39;normal&#39;</code>.</p>
<div id="gamma" class="section level3">
<h3>Gamma</h3>
<p><span class="math display">\[Duration[i] \sim Gamma(shape[i],
rate[i])\]</span> For Gamma distribution independent linear models with
a log link function are fitted for both shape and rate parameter. Priors
for intercepts for both parameters are <span class="math inline">\(\alpha ~ Normal(log(3), 5)\)</span>.</p>
</div>
<div id="log-normal" class="section level3">
<h3>Log-normal</h3>
<p><span class="math display">\[Duration[i] \sim LogNormal(\mu[i],
\sigma)\]</span> The <span class="math inline">\(\mu\)</span> parameter
is computed via a linear model with a log link function. Priors for the
intercept are <span class="math inline">\(\alpha ~ Normal(log(3),
5)\)</span>. Prior for <span class="math inline">\(\sigma\)</span> was
<span class="math inline">\(\sigma \sim Exponential(1)\)</span>.</p>
</div>
<div id="normal" class="section level3">
<h3>Normal</h3>
<p><span class="math display">\[Duration[i] \sim Normal(\mu[i],
\sigma)\]</span> The <span class="math inline">\(\mu\)</span> parameter
is computed via a linear model. Priors for the intercept are <span class="math inline">\(\alpha ~ Normal(3, 5)\)</span>. Prior for <span class="math inline">\(\sigma\)</span> was <span class="math inline">\(\sigma \sim Exponential(1)\)</span>.</p>
</div>
</div>
<div id="model-comparison" class="section level2">
<h2>Model comparison</h2>
<p>Models fits can be compared via information criteria. Specifically,
the log likelihood is stored in a <code>log_lik</code> parameter that
can be directly using <code>loo::extract_log_lik()</code> function (see
package <span class="citation">(@ <strong>loo?</strong>)</span>) or used
to compute either a leave-one-out cross-validation (via
<code>loo()</code> convenience function) or WAIC (via
<code>waic()</code>). These are information criteria that can be used
for model comparison the same way as Akaike (AIC), Bayesian (BIC), or
deviance (DIC) information criteria. The latter can also be computed
from log likelihood, however, WAIC and LOOCV are both preferred for
multi-level models, see <span class="citation">(Vehtari, Gelman, and
Gabry 2017)</span>. The model comparison itself can be performed via
<code>loo::loo_compare()</code> function of the <code>loo</code>
package.</p>
</div>
<div id="predicted-values" class="section level2">
<h2>Predicted values</h2>
<p>You can predict durations for individual dominance phases via
<code>predict()</code> function. You have an option of getting a summary
(an average expected duration plus an optional credible interval) or
computing predicted durations for every sample.</p>
<p>For summary statistics with 89% credible interval.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>predictions <span class="ot">&lt;-</span> <span class="fu">predict</span>(gam_fit, <span class="at">summary =</span> <span class="cn">TRUE</span>, <span class="at">probs =</span> <span class="fu">c</span>((<span class="dv">1</span><span class="fl">-0.89</span>)<span class="sc">/</span><span class="dv">2</span>, <span class="dv">1</span> <span class="sc">-</span> (<span class="dv">1</span><span class="fl">-0.89</span>)<span class="sc">/</span><span class="dv">2</span>))</span></code></pre></div>
<p>Predictions for every sample for <em>full length time-series</em>
(invalid samples are filled with <code>NA</code>):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>prediction_samples <span class="ot">&lt;-</span> <span class="fu">predict</span>(gam_fit, <span class="at">summary =</span> <span class="cn">FALSE</span>, <span class="at">full_length =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>Predictions for every sample only for valid samples:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>prediction_samples <span class="ot">&lt;-</span> <span class="fu">predict</span>(gam_fit, <span class="at">summary =</span> <span class="cn">FALSE</span>, <span class="at">full_length =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
</div>
<div id="computing-and-using-cumulative-history" class="section level2">
<h2>Computing and using cumulative history</h2>
<p>If you are interested in the cumulative history itself, you can
extract from the fitted object via <code>predict_history()</code>
function. Note that there are five different history types you can
extract:</p>
<ul>
<li><code>&quot;1&quot;</code>: cumulative history for the first perceptual state,
i.e., state with index of 1.</li>
<li><code>&quot;2&quot;</code>: cumulative history for the second perceptual
state, i.e., state with index of 2.</li>
<li><code>&quot;dominant&quot;</code>: for the state that is dominant during the
following phase.</li>
<li><code>&quot;suppressed&quot;</code>: for the state that is suppressed during
the following phase.</li>
<li><code>&quot;difference&quot;</code>: difference between cumulative histories
(<span class="math inline">\(\Delta h = h_{suppressed} -
h{dominant}\)</span>), which is used in linear models.</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>H <span class="ot">&lt;-</span> <span class="fu">predict_history</span>(gam_fit, <span class="st">&quot;difference&quot;</span>)</span></code></pre></div>
<p>Alternatively, you can skip fitting and compute history directly
using predefined values via <code>compute_history()</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">compute_history</span>(br_singleblock,</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">state=</span><span class="st">&quot;State&quot;</span>,</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>                      <span class="at">duration=</span><span class="st">&quot;Duration&quot;</span>, </span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>                      <span class="at">tau=</span><span class="dv">1</span>,</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>                      <span class="at">mixed_state=</span><span class="fl">0.5</span>,</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>                      <span class="at">history_init=</span><span class="dv">0</span>)</span></code></pre></div>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-Brascamp2019" class="csl-entry">
Brascamp, Jan W., Cheng Stella Qian, David Z. Hambrick, and Mark W.
Becker. 2019. <span>“<span class="nocase">Individual differences point
to two separate processes involved in the resolution of binocular
rivalry</span>.”</span> <em>Journal of Vision</em> 19 (12): 15. <a href="https://doi.org/10.1167/19.12.15">https://doi.org/10.1167/19.12.15</a>.
</div>
<div id="ref-Carpenter2017" class="csl-entry">
Carpenter, Bob, Andrew Gelman, Matthew D. Hoffman, Daniel Lee, Ben
Goodrich, Michael Betancourt, Marcus Brubaker, Jiqiang Guo, Peter Li,
and Allen Riddell. 2017. <span>“<span>Stan : A Probabilistic Programming
Language</span>.”</span> <em>Journal of Statistical Software</em> 76
(1). <a href="https://doi.org/10.18637/jss.v076.i01">https://doi.org/10.18637/jss.v076.i01</a>.
</div>
<div id="ref-Suzuki2007" class="csl-entry">
Suzuki, Satoru, and Marcia Grabowecky. 2007. <span>“<span class="nocase">Long-term speeding in perceptual switches mediated by
attention-dependent plasticity in cortical visual
processing.</span>”</span> <em>Neuron</em> 56 (4): 741–53. <a href="https://doi.org/10.1016/j.neuron.2007.09.028">https://doi.org/10.1016/j.neuron.2007.09.028</a>.
</div>
<div id="ref-Vehtari2017" class="csl-entry">
Vehtari, Aki, Andrew Gelman, and Jonah Gabry. 2017. <span>“<span class="nocase">Practical Bayesian model evaluation using leave-one-out
cross-validation and WAIC</span>.”</span> <em>Statistics and
Computing</em> 27 (5): 1413–32. <a href="https://doi.org/10.1007/s11222-016-9696-4">https://doi.org/10.1007/s11222-016-9696-4</a>.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
